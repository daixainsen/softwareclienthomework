<!--
 * @Author: pwangfeng 2199066249@qq.com
 * @Date: 2024-04-15 10:53:42
 * @LastEditors: pwangfeng 2199066249@qq.com
 * @LastEditTime: 2024-04-15 16:27:17
 * @FilePath: \client_software\sy_03.html
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 1．思考如下代码的运行结果,通过实验进行验证,同时思考最后一段代码结果的原因
        /*
        
        通过解构赋值和变量声明的方式初始化了一些变量，并输出它们的值。
        其中，a1 和 b1 没有被赋值，因此为 undefined，c1 被赋值为数组 [1, 2, 3]。
        
        */
        console.log("1．思考如下代码的运行结果,通过实验进行验证,同时思考最后一段代码结果的原因");
        let a1, b1, c1 = [1, 2, 3, ];
        console.log(a1, b1, c1);
        let [a2, b2, c2] = [1, 2, 3, ];
        console.log(a2, b2, c2);
        let [a3, b3, , c3] = [1, , 3, ];
        console.log(a3, b3, c3);
        let [a4, b4] = [1];
        console.log(a4, b4);

        let {
            y: a5,
            b5
        } = {
            x: 1,
            y: 2
        };
        console.log(a5, b5);

        let {
            a6,
            b6
        } = 123;
        console.log(a6, b6);

        // 2.运行如下代码,写出实验结果。
        console.log("2.运行如下代码,写出实验结果。");
        // 这段代码首先创建了一个Set集合，
        //并向其中添加了三个元素1、2、3，然后删除了元素2。
        //接着通过调用values()方法获取一个迭代器，然后通过next()方法逐个获取迭代器中的值并输出。
        //由于删除了元素2，所以在输出中只会包含元素1和元素3
        let set = new Set();
        set.add(1);
        set.add(2);
        set.add(3);
        set.delete(2);
        let i = set.values();
        console.log(i.next());
        console.log(i.next());
        console.log(i.next());
        // 3.运行以下代码,写出为什么最后一段代码没有输出任何结果的原因。
        console.log("3.运行以下代码,写出为什么最后一段代码没有输出任何结果的原因。");
        // 这段代码首先创建了一个Map集合，并向其中添加了四个键值对。
        // 然后通过调用keys()方法获取一个迭代器，然后通过next()方法逐个获取迭代器中的值并输出。
        let map = new Map();
        map.set(1, "a");
        map.set(2, "b");
        map.set(3, "c");
        map.set(4, "d");
        for (let i = 1; i <= map.size; i++) {
            console.log(map.get(i));
        };
        map.forEach(function(value, key) {
            console.log(value);
        });
        for (let v of map.values()) {
            console.log(v);
        };
        /*
        虽然使用了 for...in 循环来遍历 Map 对象 map，但是 for...in 循环遍历的是对象的可枚举属性，
        而 Map 对象的键值对并不是对象的属性。因此，for...in 循环无法正确遍历 Map 对象，并且不会输出任何结果。
        要遍历 Map 对象的键值对，可以使用 Map 对象提供的 forEach 方法、for...of 循环或者 Map 对象的迭代器
        */
        for (var prop in map) {
            console.log(prop);
        };
        // 4.运行如下代码,验证运行结果,并简要阐述原因。
        console.log("4.运行如下代码,验证运行结果,并简要阐述原因。");

        let arr1 = [1, 2, 3];
        let arr2 = arr1;
        /*
         将 arr1 赋值给了 arr2，它们引用的是同一个数组对象，所以 arr1 == arr2 为 true
        */
        console.log(arr1 == arr2);
        let arr3 = [...arr1];
        /*
        将 arr1 的内容复制给了 arr3，它们引用的是不同的数组对象，所以 arr1 == arr3 为 false
        */
        console.log(arr1 == arr3);
        // 遍历 map 对象的键值对，并输出值。
        map.forEach(function(value, key) {
            console.log(value);
        });
        // 使用 for...of 循环遍历 map 对象的值，并输出。
        for (let v of map.values()) {
            console.log(v);
        };
        // 使用 for...in 循环遍历 map 对象的可枚举属性，但由于 Map 对象的键值对不是对象的属性，所以不会输出任何内容。
        for (var prop in map) {
            console.log(prop);
        };
        // 5.用箭头函数改写如下代码,写出改写后的代码并运行验证。
        console.log("5.用箭头函数改写如下代码,写出改写后的代码并运行验证。");
        let arr4 = [1, 2, 3];
        arr4.forEach(function(v, k) {
            console.log(v)
        });
        map.forEach(function(value, key) {
            console.log(value);
        });
        for (let v of map.values()) {
            console.log(v);
        };
        for (var prop in map) {
            console.log(prop);
        };
        //箭头函数改写的代码
        arr4.forEach((v, k) => {
            console.log(v)
        });

        map.forEach((value, key) => {
            console.log(value);
        });

        for (let v of map.values()) {
            console.log(v);
        }

        for (var prop in map) {
            console.log(prop);
        }
        // 6.运行如下代码,写出这两句代码的作用。
        console.log("6.运行如下代码,写出这两句代码的作用。");
        /*
        这段代码首先创建一个包含数字1、2、3的数组，
        然后使用 filter 方法过滤出大于1的数字，
        最后使用 forEach 方法对过滤后的数组中的每个元素执行一个函数，
        该函数将元素输出到控制台。因此，它的作用是输出大于1的数字，即2和3。
        */
        Array.of(1, 2, 3).filter(i => i > 1).forEach(i => console.log(i));
        //斐波那契数列
        /*
        这段代码定义了一个箭头函数 fib，
        用来计算斐波那契数列中第 n 个数的值。
        斐波那契数列是一个数列，其中每个数字是前两个数字之和，
        前两个数字通常定义为0和1。这个箭头函数使用了递归的方式来计算斐波那契数列，
        当 n 大于1时，返回 fib(n - 1) + fib(n - 2)，否则返回 n
        */
        let fib = n => n > 1 ? fib(n - 1) + fib(n - 2) : n;
        // 7.运行如下代码,写出这两句代码的作用。
        console.log("7.运行如下代码,写出这两句代码的作用。");
        class Animal {
            constructor(name) {
                this.name = name;
            }

            shout() {
                console.log(`${this.name} is shouting!`);
            }
        }

        class Dog extends Animal {
            constructor(name, age) {
                super(name);
                this.age = age;
            }

            eat() {
                console.log(`${this.name} is eating.`);
            }
        }

        // 示例用法
        const myDog = new Dog("Buddy", 3);
        myDog.shout(); // 输出: Buddy is shouting!
        myDog.eat(); // 输出: Buddy is eating.
    </script>

</body>

</html>